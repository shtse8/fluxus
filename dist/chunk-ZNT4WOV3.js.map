{"version":3,"sources":["../src/providers/stateProvider.ts","../src/providers/computedProvider.ts","../src/scope.ts"],"sourcesContent":["import { ScopeReader, Provider, Dispose } from '../types.js';\r\nimport { Scope } from '../scope.js'; // Need Scope to add the updater method later\r\n\r\n// --- Type Definitions ---\r\n\r\n/**\r\n * Defines the shape of the function used to update the state of a {@link StateProviderInstance}.\r\n * This function is retrieved via `scope.updater(provider)`.\r\n *\r\n * @template T The type of the state.\r\n * @param {Scope} scope The scope instance in which the update occurs.\r\n * @param {StateProviderInstance<T>} provider The specific provider instance being updated.\r\n * @param {T | ((prev: T) => T)} newValueOrFn The new value or a function that receives the previous value and returns the new value.\r\n * @returns {void}\r\n */\r\nexport type StateUpdater<T> = (\r\n  scope: Scope,\r\n  provider: StateProviderInstance<T>,\r\n  newValue: T | ((prev: T) => T)\r\n) => void;\r\n\r\n/**\r\n * Represents the internal state associated with a specific {@link StateProviderInstance}\r\n * within a particular {@link Scope}.\r\n *\r\n * @template T The type of the state value.\r\n */\r\nexport interface StateProviderState<T> {\r\n  /** The current value of the state. */\r\n  value: T;\r\n  /** A set of listener callbacks subscribed to changes in this state within the scope. */\r\n  listeners: Set<() => void>;\r\n}\r\n\r\nexport \r\n// Using a unique symbol allows us to identify StateProvider instances\r\n// without relying on instanceof checks or specific properties.\r\nconst $stateProvider = Symbol.for('fluxus.stateProvider');\r\n\r\n/**\r\n * A specialized {@link Provider} that manages a mutable piece of state.\r\n *\r\n * It provides the current state value when read and allows the state to be\r\n * updated via an updater function obtained from the {@link Scope}.\r\n * StateProviders are the primary way to introduce mutable state into the Fluxus system.\r\n *\r\n * @template T The type of the state value.\r\n * @extends {Provider<T>}\r\n */\r\nexport interface StateProviderInstance<T> extends Provider<T> {\r\n  /** @internal A unique symbol used to identify StateProvider instances. */\r\n  [$stateProvider]: {\r\n    /**\r\n     * @internal The function called by the Scope to create the initial state\r\n     * for this provider instance within that scope.\r\n     * @param {ScopeReader} reader - The reader for the initializing scope.\r\n     * @param {number} internalId - A unique ID assigned by the scope for debugging.\r\n     * @returns {StateProviderState<T>} The initial internal state.\r\n     */\r\n    initializeState: (reader: ScopeReader, internalId: number) => StateProviderState<T>;\r\n  };\r\n  /** @internal A read-only property for easier type narrowing if needed. */\r\n  // Add a property for easier type narrowing if needed, though symbol is preferred\r\n  readonly _fluxus_provider_type: 'StateProvider';\r\n}\r\n\r\n/**\r\n * Type guard to check if a given value is a {@link StateProviderInstance}.\r\n *\r\n * @template T The potential type of the state managed by the provider.\r\n * @param {unknown} provider The value to check.\r\n * @returns {provider is StateProviderInstance<T>} True if the value is a StateProviderInstance, false otherwise.\r\n */\r\nexport function isStateProviderInstance<T>(\r\n  provider: unknown\r\n): provider is StateProviderInstance<T> {\r\n  // Check if it's a function and has the internal symbol identifier.\r\n  return typeof provider === 'function' && !!(provider as any)[$stateProvider];\r\n}\r\n\r\n\r\n// --- Factory Function ---\r\n\r\n/**\r\n * Creates a {@link StateProviderInstance} which manages a mutable piece of state.\r\n *\r\n * @template T The type of the state value.\r\n * @param {T | ((reader: ScopeReader) => T)} initialValue - The initial value for the state,\r\n *   or a function that computes the initial value using a {@link ScopeReader}.\r\n *   If a function is provided, it will be called once per scope when the provider\r\n *   is first initialized within that scope.\r\n * @returns {StateProviderInstance<T>} The created StateProvider instance.\r\n *\r\n * @example\r\n * // Simple counter state provider\r\n * const counterProvider = stateProvider(0);\r\n *\r\n * // State provider with initial value computed from another provider\r\n * const userProvider = stateProvider<{ name: string; id: number } | null>(null);\r\n * const userIdProvider = stateProvider((reader) => reader.read(userProvider)?.id ?? -1);\r\n */\r\nexport function stateProvider<T>(\r\n  initialValue: T | ((reader: ScopeReader) => T)\r\n): StateProviderInstance<T> {\r\n\r\n  // This is the core function that Scope will call to initialize the provider's state.\r\n  // Accept internalId from Scope\r\n  const initializeState = (reader: ScopeReader, internalId: number): StateProviderState<T> => {\r\n    let currentValue = typeof initialValue === 'function'\r\n      ? (initialValue as (reader: ScopeReader) => T)(reader)\r\n      : initialValue;\r\n\r\n    const state: StateProviderState<T> = {\r\n      value: currentValue,\r\n      listeners: new Set(),\r\n      // Updater is no longer defined here\r\n    };\r\n\r\n    // No specific disposal needed for the value itself unless initialValue function uses onDispose\r\n    // reader.onDispose(() => { console.log('Disposing state provider state'); });\r\n\r\n    return state;\r\n  };\r\n\r\n  // This function represents the Provider<T> interface.\r\n  // When scope.read(stateProviderInstance) is called, the Scope internally\r\n  // handles retrieving the actual state value from its map using the\r\n  // stateProviderInstance as the key. This function itself doesn't need\r\n  // to contain the read logic directly.\r\n  const providerFn: Provider<T> = () => {\r\n    // This function body is effectively unused at runtime because the Scope's\r\n    // read/initializeProviderState methods handle the logic based on the\r\n    // presence of the [$stateProvider] symbol.\r\n    // Throwing an error here helps catch incorrect direct invocation.\r\n    throw new Error(\r\n      'StateProvider function should not be called directly. Use scope.read(provider).'\r\n    );\r\n  };\r\n\r\n  // Attach the metadata/initializer function using the symbol\r\n  (providerFn as any)[$stateProvider] = { initializeState };\r\n  (providerFn as any)._fluxus_provider_type = 'StateProvider';\r\n\r\n\r\n  return providerFn as StateProviderInstance<T>;\r\n}\r\n\r\n// --- Scope Extension (Conceptual - needs integration into Scope class) ---\r\n\r\n// We need to modify the Scope class to:\r\n// 1. Recognize StateProviderInstance when initializing state.\r\n// 2. Store the *entire* StateProviderState (value + updater + listeners) internally.\r\n// 3. Return only the `value` when `scope.read(stateProviderInstance)` is called.\r\n// 4. Provide a new method `scope.updater(stateProviderInstance)` to retrieve the updater.\r\n\r\n/*\r\n// Example of how Scope might be extended:\r\n\r\ndeclare module '../scope' {\r\n  interface Scope {\r\n    updater<T>(provider: StateProviderInstance<T>): StateUpdater<T>;\r\n    // Internal method might be needed\r\n    // getStateProviderState<T>(provider: StateProviderInstance<T>): StateProviderState<T> | undefined;\r\n  }\r\n}\r\n\r\n// Implementation within Scope class would involve checking the symbol\r\n// during initialization and read, and adding the `updater` method.\r\n*/","import { ScopeReader, Provider, Dispose } from '../types.js';\r\nimport { Scope } from '../scope.js'; // May be needed later\r\n\r\n// --- Type Definitions ---\r\n\r\n/**\r\n * Represents the internal state associated with a specific {@link ComputedProviderInstance}\r\n * within a particular {@link Scope}. Computed providers typically don't have listeners\r\n * themselves but rely on dependencies notifying them to become stale.\r\n *\r\n * @template T The type of the computed state value.\r\n */\r\n// Note: For now, computed providers will use GenericProviderState internally in the Scope,\r\n// as their value is computed once and cached until marked stale.\r\n// We might introduce a specific state type later if needed for optimizations.\r\n\r\n/** A unique symbol to identify ComputedProvider instances. */\r\nexport const $computedProvider = Symbol.for('fluxus.computedProvider');\r\n\r\n/**\r\n * Represents an instance of a ComputedProvider.\r\n * It acts as a Provider<T> for reading the computed value. It carries metadata\r\n * via a symbol to distinguish it during initialization.\r\n *\r\n * @template T The type of the computed value.\r\n * @extends {Provider<T>}\r\n */\r\nexport interface ComputedProviderInstance<T> extends Provider<T> {\r\n  /** @internal A unique symbol used to identify ComputedProvider instances. */\r\n  [$computedProvider]: {\r\n    /**\r\n     * @internal The computation function provided when the provider was created.\r\n     * This function is called by the Scope during initialization or recomputation.\r\n     * @param {ScopeReader} reader - The reader for the current scope.\r\n     * @returns {T} The computed value.\r\n     */\r\n    compute: (reader: ScopeReader) => T;\r\n  };\r\n  /** @internal A read-only property for easier type narrowing if needed. */\r\n  readonly _fluxus_provider_type: 'ComputedProvider';\r\n}\r\n\r\n/**\r\n * Type guard to check if a given value is a {@link ComputedProviderInstance}.\r\n *\r\n * @template T The potential type of the computed value.\r\n * @param {unknown} provider The value to check.\r\n * @returns {provider is ComputedProviderInstance<T>} True if the value is a ComputedProviderInstance, false otherwise.\r\n */\r\nexport function isComputedProviderInstance<T>(\r\n  provider: unknown\r\n): provider is ComputedProviderInstance<T> {\r\n  // Check if it's a function and has the internal symbol identifier.\r\n  return typeof provider === 'function' && !!(provider as any)[$computedProvider];\r\n}\r\n\r\n\r\n// --- Factory Function ---\r\n\r\n/**\r\n * Creates a {@link ComputedProviderInstance} which derives its state by computing\r\n * a value based on other providers.\r\n *\r\n * The computation function is executed lazily when the provider is first read\r\n * within a scope, and its result is cached. The computed value is automatically\r\n * re-evaluated when any of the providers it `read` or `watch`ed during the\r\n * computation change their state.\r\n *\r\n * @template T The type of the computed value.\r\n * @param {(reader: ScopeReader) => T} compute - The function that computes the\r\n *   derived state. It receives a {@link ScopeReader} to access other providers.\r\n *   It's crucial to use `reader.watch` or `reader.read` within this function\r\n *   to establish dependencies correctly for automatic recomputation.\r\n * @returns {ComputedProviderInstance<T>} The created ComputedProvider instance.\r\n *\r\n * @example\r\n * const countProvider = stateProvider(0);\r\n * const doubleCountProvider = computedProvider((reader) => {\r\n *   const count = reader.watch(countProvider); // Establish dependency\r\n *   const count = reader.watch(countProvider); // Establish dependency\r\n *   return count * 2;\r\n * });\r\n *\r\n * @see {@link stateProvider} for creating mutable state.\r\n * @see {@link ScopeReader} for how to access dependencies.\r\n * });\r\n */\r\nexport function computedProvider<T>(\r\n  compute: (reader: ScopeReader) => T\r\n): ComputedProviderInstance<T> {\r\n\r\n  // This function represents the Provider<T> interface.\r\n  // Similar to StateProvider, the actual logic happens within the Scope\r\n  // based on the metadata attached via the symbol.\r\n  const providerFn: Provider<T> = () => {\r\n    throw new Error(\r\n      'ComputedProvider function should not be called directly. Use scope.read(provider).'\r\n    );\r\n  };\r\n\r\n  // Attach metadata\r\n  (providerFn as any)[$computedProvider] = { compute };\r\n  (providerFn as any)._fluxus_provider_type = 'ComputedProvider';\r\n\r\n  return providerFn as ComputedProviderInstance<T>;\r\n}","import { Provider, ScopeReader, Dispose, Disposable, isProvider } from './types.js';\r\nimport {\r\n  StateProviderInstance,\r\n  isStateProviderInstance,\r\n  StateUpdater,\r\n  StateProviderState,\r\n  $stateProvider\r\n} from './providers/stateProvider.js';\r\nimport {\r\n    ComputedProviderInstance,\r\n    isComputedProviderInstance,\r\n    $computedProvider\r\n} from './providers/computedProvider.js';\r\n\r\n// --- Internal State Types ---\r\n\r\n/** Common fields for all internal provider states within a scope. */\r\nlet internalStateIdCounter = 0; // Counter for unique IDs\r\n\r\ninterface BaseInternalState extends Disposable {\r\n  /** Unique ID for debugging state instances */\r\n  readonly internalId: number;\r\n  /** Explicitly add dispose signature to help TS inference */\r\n  dispose: Dispose;\r\n  /** List of functions to call when this state is disposed. */\r\n  disposeCallbacks: Set<Dispose>;\r\n  /** Set of providers that this provider depends on. */\r\n  dependencies: Set<Provider<any>>;\r\n  /** Set of providers that depend on this provider. */\r\n  dependents: Set<Provider<any>>;\r\n  /** Flag indicating if the value is currently being computed (to detect circular dependencies). */\r\n  isComputing: boolean;\r\n  /** Flag indicating if the state has been disposed. */\r\n  isDisposed: boolean;\r\n  /** Flag indicating if the provider's value might be outdated due to dependency changes. */\r\n  isStale: boolean;\r\n}\r\n\r\n/** Internal state for regular (non-StateProvider) providers. */\r\ninterface GenericProviderState<T> extends BaseInternalState {\r\n  type: 'generic';\r\n  /** The computed value of the provider. */\r\n  value: T;\r\n}\r\n\r\n/** Internal state specific to StateProviders. */\r\ninterface StateProviderInternalState<T> extends BaseInternalState {\r\n  type: 'state';\r\n  /** The specific state managed by the StateProvider (value, updater, listeners). */\r\n  stateProviderState: StateProviderState<T>;\r\n}\r\n\r\n/** Union type for all possible internal states stored in the scope. */\r\ntype InternalState<T> = GenericProviderState<T> | StateProviderInternalState<T>;\r\n\r\n// Type guard for StateProviderInternalState\r\nfunction isStateProviderInternalState<T>(\r\n  state: InternalState<any> | undefined\r\n): state is StateProviderInternalState<any> { // Use <any> here\r\n  return state?.type === 'state';\r\n}\r\n\r\n/**\r\n * Manages the state and lifecycle of providers within a specific context.\r\n * Scopes can be nested to allow for overriding providers in different parts\r\n * of an application. Each scope maintains its own instance of provider states.\r\n *\r\n * @implements {Disposable}\r\n */\r\nexport class Scope implements Disposable {\r\n  /** Stores the state associated with each provider within this scope. */\r\n  private providerStates = new Map<Provider<any>, InternalState<any>>();\r\n  /** Optional parent scope for provider overrides and nesting. */\r\n  private parent: Scope | null;\r\n  /** Flag indicating if the scope itself has been disposed. */\r\n  private _isDisposed = false; // Renamed internal flag\r\n\r\n  /**\r\n   * Indicates whether the scope has been disposed. Once disposed, a scope\r\n   * cannot be used to read or initialize providers.\r\n   * @returns {boolean} True if the scope is disposed, false otherwise.\r\n   */\r\n  public get isDisposed(): boolean {\r\n      return this._isDisposed;\r\n  }\r\n\r\n  /**\r\n   * Creates a new Scope instance.\r\n   * @param {Scope | null} [parent=null] - An optional parent scope. If provided,\r\n   *        this scope can potentially inherit or override providers from the parent\r\n   *        (behavior depends on specific provider implementations and future features).\r\n   */\r\n  constructor(parent: Scope | null = null) {\r\n    this.parent = parent;\r\n  }\r\n\r\n  /** Checks if the scope or its ancestors have been disposed. */\r\n  private checkDisposed(): void {\r\n    if (this._isDisposed) { // Use internal flag\r\n      throw new Error('Scope has been disposed');\r\n    }\r\n    // Recursively check parent scopes if necessary, though direct check might suffice\r\n    // if disposal propagates correctly.\r\n  }\r\n\r\n  /**\r\n   * Reads the current value of a given provider within this scope.\r\n   *\r\n   * If the provider has already been initialized in this scope, its cached value\r\n   * is returned. If the provider's state is marked as stale (due to a dependency change),\r\n   * it will be recomputed before returning the value.\r\n   *\r\n   * If the provider has not been initialized, its creation function will be executed,\r\n   * its dependencies tracked, and the resulting value cached and returned.\r\n   *\r\n   * Throws an error if the scope or the specific provider state has been disposed,\r\n   * or if a circular dependency is detected during initialization.\r\n   *\r\n   * @template T The type of the value provided.\r\n   * @param {Provider<T>} provider The provider function/object to read.\r\n   * @returns {T} The current value of the provider.\r\n   * @throws {Error} If the scope or provider state is disposed.\r\n   * @throws {Error} If a circular dependency is detected.\r\n   */\r\n  public read<T>(provider: Provider<T>): T {\r\n    this.checkDisposed();\r\n\r\n    // 1. Check local cache\r\n    let state = this.providerStates.get(provider) as InternalState<T> | undefined;\r\n\r\n    if (state) {\r\n      // State exists in cache\r\n      if (state.isComputing) {\r\n        throw new Error('Circular dependency detected');\r\n      }\r\n      if (state.isDisposed) {\r\n        throw new Error('Cannot read provider: its state has been disposed');\r\n      }\r\n      if (state.isStale) {\r\n        // State is stale, recompute (only applicable to GenericProviderState)\r\n        if (isStateProviderInternalState(state)) {\r\n          // Should not happen for StateProvider, but return value if it does\r\n          return state.stateProviderState.value;\r\n        } else {\r\n          // Recompute Generic/Computed provider\r\n          return this._computeAndCacheValue(provider, state as GenericProviderState<T>);\r\n        }\r\n      } else {\r\n        // State is valid and not stale, return cached value\r\n        if (isStateProviderInternalState(state)) {\r\n          return state.stateProviderState.value;\r\n        } else {\r\n          return (state as GenericProviderState<T>).value;\r\n        }\r\n      }\r\n    } else {\r\n      // State not found in cache, initialize structure and compute value\r\n      const newState = this._createProviderStateStructure(provider);\r\n      if (isStateProviderInternalState(newState)) {\r\n        // StateProvider value was already computed during structure creation\r\n        return newState.stateProviderState.value;\r\n      } else {\r\n        // For Generic/Computed, compute the value now using the newly created state structure\r\n        return this._computeAndCacheValue(provider, newState as GenericProviderState<T>);\r\n      }\r\n    }\r\n  }\r\n\r\n   /**\r\n   * Creates the internal state structure for a given provider within this scope,\r\n   * but does not compute the initial value unless it's a StateProvider.\r\n   * Sets up internal state tracking (dependencies, dependents, lifecycle callbacks).\r\n   * This method is called internally by `read` when a provider is accessed\r\n   * for the first time.\r\n   *\r\n   * @template T The type of the value provided.\r\n   * @param {Provider<T>} provider The provider to initialize the state structure for.\r\n   * @returns {InternalState<T>} The created internal state structure.\r\n   * @private\r\n   */\r\n  private _createProviderStateStructure<T>(provider: Provider<T>): InternalState<T> {\r\n    // --- Common setup for reader and base state ---\r\n    const dependencies = new Set<Provider<any>>();\r\n    const dependents = new Set<Provider<any>>();\r\n    const disposeCallbacks = new Set<Dispose>();\r\n\r\n    // Create and store a placeholder state immediately to detect cycles\r\n    const internalId = internalStateIdCounter++; // Assign unique ID\r\n    const placeholderState: InternalState<any> = {\r\n        internalId,\r\n        type: 'generic', // Placeholder type\r\n        value: undefined,\r\n        isComputing: true,\r\n        isDisposed: false,\r\n        isStale: false,\r\n        dependencies,\r\n        dependents,\r\n        disposeCallbacks,\r\n        dispose: () => { /* Placeholder dispose, real one set later */ }\r\n    };\r\n    this.providerStates.set(provider, placeholderState);\r\n\r\n    // Define the base disposal logic here, capturing necessary variables\r\n    const baseDisposeLogic = (stateRef: InternalState<any>, providerKey: Provider<any>) => {\r\n        if (stateRef.isDisposed) return;\r\n\r\n        // Mark dependents as stale *before* cleaning up this state\r\n        this.markDependentsStale(providerKey, new Set());\r\n\r\n        stateRef.isDisposed = true; // Mark as disposed\r\n\r\n        if (isStateProviderInternalState(stateRef)) {\r\n            stateRef.stateProviderState.listeners.clear();\r\n        }\r\n        stateRef.disposeCallbacks.forEach(cb => { try { cb() } catch (e) { console.error(\"Error during dispose callback:\", e)} });\r\n        stateRef.disposeCallbacks.clear();\r\n\r\n        // Clean up dependency links *before* clearing local dependencies set\r\n        stateRef.dependencies.forEach(depProvider => {\r\n            const depState = this.providerStates.get(depProvider);\r\n            if (depState && 'dependents' in depState) {\r\n                 depState.dependents.delete(providerKey); // Use providerKey here\r\n            }\r\n        });\r\n        // Clear local sets captured by the state object itself\r\n        stateRef.dependencies.clear();\r\n        stateRef.dependents.clear();\r\n\r\n        // Keep the state object in the map but marked as disposed.\r\n    };\r\n\r\n    // Determine state type and create final structure\r\n    let internalState: InternalState<T>;\r\n    if (isStateProviderInstance<T>(provider)) {\r\n      // State providers require their specific internal state initialized immediately\r\n      const initReader: ScopeReader = {\r\n          read: <P>(dep: Provider<P>) => this.read(dep),\r\n          watch: <P>(dep: Provider<P>) => this.read(dep), // Watch behaves like read during init\r\n          onDispose: (cb: Dispose) => disposeCallbacks.add(cb),\r\n      };\r\n      const stateProviderState = (provider as any)[$stateProvider].initializeState(initReader, internalId);\r\n      internalState = {\r\n        internalId,\r\n        type: 'state',\r\n        stateProviderState: stateProviderState,\r\n        disposeCallbacks,\r\n        dependencies, // Use the set populated by initReader\r\n        dependents,\r\n        isComputing: false,\r\n        isDisposed: false,\r\n        isStale: false, // Initial value is never stale\r\n        dispose: () => baseDisposeLogic(internalState, provider),\r\n      };\r\n    } else {\r\n      // For computed and generic providers, create a generic structure.\r\n      internalState = {\r\n        internalId,\r\n        type: 'generic',\r\n        value: undefined as T, // Value starts undefined\r\n        disposeCallbacks,\r\n        dependencies, // Will be populated by _computeAndCacheValue\r\n        dependents,\r\n        isComputing: false,\r\n        isDisposed: false,\r\n        isStale: true, // Mark as stale initially\r\n        dispose: () => baseDisposeLogic(internalState, provider),\r\n      };\r\n    }\r\n\r\n    // Replace placeholder and return the created structure\r\n    this.providerStates.set(provider, internalState);\r\n    return internalState;\r\n  }\r\n\r\n  /**\r\n   * Computes or recomputes the value for a generic or computed provider,\r\n   * updates its state, and returns the new value.\r\n   *\r\n   * @template T The type of the value provided.\r\n   * @param {Provider<T>} provider The provider being computed.\r\n   * @param {GenericProviderState<T>} state The internal state object for the provider.\r\n   * @returns {T} The computed value.\r\n   * @private\r\n   */\r\n  private _computeAndCacheValue<T>(\r\n    provider: Provider<T>,\r\n    state: GenericProviderState<T>\r\n  ): T {\r\n    // Create a reader specific to this computation\r\n    const dependencies = new Set<Provider<any>>();\r\n\r\n    // Clear old dependencies links *before* re-computation\r\n    state.dependencies.forEach(oldDepProvider => {\r\n        const oldDepState = this.providerStates.get(oldDepProvider);\r\n        if (oldDepState && 'dependents' in oldDepState) {\r\n            oldDepState.dependents.delete(provider);\r\n        }\r\n    });\r\n    state.dependencies.clear(); // Clear the local set\r\n\r\n    const reader: ScopeReader = {\r\n      read: <P>(depProvider: Provider<P>): P => {\r\n        dependencies.add(depProvider); // Track new dependency for the provider being computed\r\n        const value = this.read(depProvider); // Delegate read (this might initialize depProvider)\r\n        // Re-fetch the state *after* reading, ensuring it's initialized\r\n        const depState = this.providerStates.get(depProvider);\r\n        // Add the provider *being computed* to the dependents list of the dependency\r\n        if (depState && 'dependents' in depState) {\r\n             // console.log(`DEBUG _compute reader.read: Adding dependent ${state.internalId} to dependency ${depState.internalId}`); // Optional debug\r\n             depState.dependents.add(provider); // 'provider' is the one being computed\r\n        }\r\n        return value;\r\n      },\r\n      watch: <P>(depProvider: Provider<P>): P => {\r\n         dependencies.add(depProvider); // Track new dependency for the provider being computed\r\n         const value = this.read(depProvider); // Delegate read (this might initialize depProvider)\r\n         // Re-fetch the state *after* reading, ensuring it's initialized\r\n         const depState = this.providerStates.get(depProvider);\r\n         // Add the provider *being computed* to the dependents list of the dependency\r\n         if (depState && 'dependents' in depState) {\r\n             // console.log(`DEBUG _compute reader.watch: Adding dependent ${state.internalId} to dependency ${depState.internalId}`); // Optional debug\r\n             depState.dependents.add(provider); // 'provider' is the one being computed\r\n         }\r\n         // TODO: Establish actual subscription?\r\n         return value;\r\n      },\r\n      onDispose: (callback: Dispose): void => {\r\n        if (state.isDisposed) return;\r\n        state.disposeCallbacks.add(callback);\r\n      }\r\n    };\r\n\r\n    state.isComputing = true;\r\n    let newValue: T;\r\n    try {\r\n      // Determine how to get the value based on provider type\r\n      if (isComputedProviderInstance<T>(provider)) {\r\n        newValue = (provider as any)[$computedProvider].compute(reader);\r\n      } else {\r\n        newValue = provider(reader); // Generic provider\r\n      }\r\n\r\n      // Update state\r\n      state.value = newValue;\r\n      state.dependencies = dependencies; // Store the new dependencies\r\n      state.isStale = false;\r\n      state.isComputing = false;\r\n      return newValue;\r\n\r\n    } catch (error) {\r\n      state.isComputing = false;\r\n      // Re-throw error but leave state potentially stale/partially cleaned?\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the specialized updater function for a {@link StateProviderInstance}.\r\n   *\r\n   * This method ensures the provider is initialized and is indeed a `StateProvider`.\r\n   * It returns a function that, when called, will update the provider's state\r\n   * within this specific scope and notify listeners and dependents.\r\n   *\r\n   * Throws an error if the scope is disposed, the provider is not a `StateProviderInstance`,\r\n   * or the provider state is disposed or inconsistent.\r\n   *\r\n   * @template T The type of the state managed by the StateProvider.\r\n   * @param {StateProviderInstance<T>} provider The StateProviderInstance whose updater is needed.\r\n   * @returns {StateUpdater<T>} The updater function bound to this scope and provider.\r\n   * @throws {Error} If the scope is disposed.\r\n   * @throws {Error} If the provider is not a valid, initialized StateProvider in this scope.\r\n   */\r\n  public updater<T>(provider: StateProviderInstance<T>): StateUpdater<T> {\r\n    this.checkDisposed();\r\n    // Check if the provider is initialized and is actually a StateProvider *before* returning the updater function.\r\n    // Reading it ensures initialization.\r\n    this.read(provider); // Ensure initialized and get potential errors early\r\n    const state = this.providerStates.get(provider);\r\n\r\n    // Perform the check here\r\n    if (!isStateProviderInternalState<T>(state)) {\r\n         throw new Error('Provider is not a StateProvider or state is inconsistent');\r\n    }\r\n     if (state.isDisposed) {\r\n        // This check might be redundant if read() already threw, but keep for safety\r\n        throw new Error('Cannot get updater for a disposed provider state');\r\n    }\r\n\r\n\r\n    // Return a function that performs the update using the current scope instance ('this')\r\n    // and the specific provider key.\r\n    return (scopeInstance: Scope, providerInstance: StateProviderInstance<T>, newValueOrFn: T | ((prev: T) => T)) => {\r\n        // Check scope disposal *again* inside the returned function, as it might be called later\r\n        try {\r\n            scopeInstance.checkDisposed();\r\n        } catch (e) {\r\n             return;\r\n        }\r\n\r\n        const currentState = scopeInstance.providerStates.get(providerInstance) as StateProviderInternalState<T> | undefined;\r\n\r\n        // Check if the state exists, is the correct type, and is not disposed\r\n        if (!currentState || !isStateProviderInternalState(currentState) || currentState.isDisposed) {\r\n            // Log the ID we attempted to find state for, if possible\r\n            const attemptedId = currentState ? currentState.internalId : 'unknown';\r\n            return;\r\n        }\r\n\r\n\r\n        const stateProviderState = currentState.stateProviderState;\r\n        const previousValue = stateProviderState.value;\r\n\r\n        const newValue = typeof newValueOrFn === 'function'\r\n            ? (newValueOrFn as (prev: T) => T)(previousValue)\r\n            : newValueOrFn;\r\n\r\n        if (!Object.is(previousValue, newValue)) {\r\n            stateProviderState.value = newValue;\r\n            // Notify listeners from the *current* state\r\n            const listenersToNotify = Array.from(stateProviderState.listeners);\r\n            listenersToNotify.forEach(listener => listener());\r\n\r\n            // Mark dependents as stale and notify their listeners\r\n            scopeInstance.markDependentsStale(providerInstance, new Set());\r\n        }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Recursively marks dependents of a given provider as stale and notifies\r\n   * any listeners attached to those dependents (primarily for UI updates via `watch`).\r\n   * This is called when a provider's state changes.\r\n   *\r\n   * Uses a Set to track visited providers in the current propagation chain\r\n   * to prevent infinite loops in potential (though ideally non-existent)\r\n   * circular dependency scenarios during notification.\r\n   *\r\n   * @param {Provider<any>} provider The provider whose dependents should be marked stale.\r\n   * @param {Set<Provider<any>>} visited Set of providers already visited in this notification chain.\r\n   * @private\r\n   */\r\n  private markDependentsStale(provider: Provider<any>, visited: Set<Provider<any>>): void {\r\n    // DEBUG: Log entry and the provider being processed\r\n    const providerState = this.providerStates.get(provider);\r\n    // console.log(`DEBUG: Entering markDependentsStale for provider (Internal ID: ${providerState?.internalId ?? 'N/A'})`);\r\n    if (visited.has(provider)) {\r\n        return; // Avoid infinite loops\r\n    }\r\n    visited.add(provider);\r\n\r\n    const state = this.providerStates.get(provider);\r\n    if (!state || state.isDisposed) return;\r\n\r\n    state.dependents.forEach(dependentProvider => {\r\n        const dependentState = this.providerStates.get(dependentProvider);\r\n        // Check if dependent exists and is not disposed\r\n        if (dependentState && !dependentState.isDisposed) {\r\n            // Mark stale unconditionally if it wasn't already.\r\n            // This ensures the staleness propagates even if listeners aren't notified directly.\r\n            const wasAlreadyStale = dependentState.isStale;\r\n            if (!wasAlreadyStale) {\r\n                 // console.log(`DEBUG markDependentsStale: Marking dependent ${dependentState.internalId} as stale.`); // DEBUG\r\n                 dependentState.isStale = true;\r\n            }\r\n\r\n            // Notify listeners if it's a StateProvider (listeners are only stored there currently)\r\n            if (isStateProviderInternalState(dependentState)) {\r\n                const listeners = dependentState.stateProviderState.listeners;\r\n                 if (listeners.size > 0) {\r\n                    // console.log(`DEBUG markDependentsStale: Notifying ${listeners.size} listeners of stale StateProvider ${dependentState.internalId}.`); // DEBUG\r\n                    // Convert to array before iterating in case a listener modifies the set during iteration\r\n                    Array.from(listeners).forEach(listener => listener());\r\n                 }\r\n            }\r\n\r\n            // Recursively mark *its* dependents as stale\r\n            this.markDependentsStale(dependentProvider, visited);\r\n        }\r\n    });\r\n  }\r\n  /**\r\n   * Subscribes a listener function to changes in a specific provider's state within this scope.\r\n   *\r\n   * Currently, only {@link StateProviderInstance} actively supports notifications. Watching\r\n   * other provider types might read the initial value but won't trigger the callback\r\n   * on changes (unless they are dependents of a changing StateProvider, triggering staleness).\r\n   *\r\n   * Ensures the provider is initialized before attempting to add the listener.\r\n   * Implements auto-disposal: when the last listener for a provider unsubscribes,\r\n   * the provider's internal state is disposed.\r\n   *\r\n   * @template T The type of the value provided.\r\n   * @param {Provider<T>} provider The provider to watch.\r\n   * @param {() => void} callback The function to call when the provider's state changes.\r\n   * @returns {Dispose} A function to call to unsubscribe the listener.\r\n   */\r\n  public watch<T>(provider: Provider<T>, callback: () => void): Dispose {\r\n    this.checkDisposed();\r\n\r\n    // Ensure the provider is initialized by reading it first.\r\n    // This also retrieves the current state if already initialized.\r\n    this.read(provider);\r\n    const state = this.providerStates.get(provider);\r\n\r\n    if (!state || state.isDisposed) {\r\n      // Should not happen if read() succeeded, but check for safety.\r\n      return () => {}; // Return a no-op unsubscribe function\r\n    }\r\n\r\n    // Currently, only StateProviders actively notify listeners.\r\n    // Other provider types (computed, future) will need different mechanisms.\r\n    // TODO: Generalize listener handling? Add listeners set to BaseInternalState?\r\n    if (isStateProviderInternalState(state)) {\r\n      const listeners = state.stateProviderState.listeners;\r\n      listeners.add(callback);\r\n\r\n      // Return the unsubscribe function\r\n      return () => {\r\n        listeners.delete(callback);\r\n        // Auto-dispose if listener count drops to zero\r\n        if (listeners.size === 0) {\r\n            // We need to access the state again here, using the provider key\r\n            // The 'state' variable from the outer scope should still be valid here\r\n            // Check if it still exists and hasn't been disposed by other means\r\n            if (state && !state.isDisposed) {\r\n                 // console.log(`DEBUG: Auto-disposing state due to zero listeners (Internal ID: ${state.internalId})`); // Optional debug\r\n                 state.dispose(); // Dispose the internal state\r\n            }\r\n        }\r\n      };\r\n    } else {\r\n      // For generic/computed providers, there's nothing to watch directly yet.\r\n      // Re-computation happens via staleness check in `read`.\r\n      // Return a no-op unsubscribe.\r\n      return () => {};\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Disposes of the scope, cleaning up all provider states created within it.\r\n   *\r\n   * This involves:\r\n   * - Marking the scope itself as disposed.\r\n   * - Iterating through all active provider states in the scope.\r\n   * - Calling the `dispose` method on each provider state, which in turn:\r\n   *   - Clears internal listeners (for StateProviders).\r\n   *   - Executes any `onDispose` callbacks registered during provider initialization.\r\n   *   - Cleans up dependency/dependent links.\r\n   * - Clearing the internal map of provider states.\r\n   *\r\n   * Once disposed, the scope and its provider states should not be used further.\r\n   */\r\n  public dispose(): void {\r\n    if (this.isDisposed) {\r\n      return;\r\n    }\r\n    this._isDisposed = true; // Use internal flag\r\n\r\n    // Dispose providers in reverse order of initialization? Not strictly necessary\r\n    // if dependencies are handled correctly, but might prevent some issues.\r\n    // For now, dispose in map iteration order.\r\n    // Create a copy of states to dispose, as disposal modifies the map\r\n    const statesToDispose = Array.from(this.providerStates.values());\r\n    statesToDispose.forEach(state => {\r\n      // Ensure dispose is called only once via the state's internal flag\r\n      if (!state.isDisposed) {\r\n          state.dispose();\r\n      }\r\n    });\r\n\r\n    this.providerStates.clear();\r\n    this.parent = null; // Break potential reference cycle\r\n    // console.log(\"Scope disposed\");\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create a new {@link Scope}.\r\n * @param {Scope | null} [parent=null] - An optional parent scope.\r\n * @returns {Scope} A new Scope instance.\r\n */\r\nexport function createScope(parent: Scope | null = null): Scope {\r\n    return new Scope(parent);\r\n}\r\n\r\n// Example usage (conceptual)\r\n// const scope = createScope();\r\n// const value = scope.read(myProvider);\r\n// scope.dispose();"],"mappings":"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","names":[]}
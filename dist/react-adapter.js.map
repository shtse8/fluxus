{"version":3,"sources":["../react-adapter/ProviderScope.tsx","../react-adapter/context.ts","../react-adapter/hooks.ts"],"sourcesContent":["import * as React from 'react';\r\nimport { Scope, createScope } from '../src/scope.js';\r\nimport { ScopeContext } from './context.js';\r\n\r\n/**\r\n * Props for the {@link ProviderScope} component.\r\n */\r\ninterface ProviderScopeProps {\r\n  /** The child components that will have access to the scope created by this ProviderScope. */\r\n  children: React.ReactNode;\r\n  /** Optional: Provide specific provider overrides for this scope. (Not yet implemented) */\r\n  // overrides?: ProviderOverride[];\r\n}\r\n\r\n/**\r\n * A React component that creates and manages a Fluxus {@link Scope} instance\r\n * and provides it to descendant components via React Context.\r\n *\r\n * This is the entry point for using Fluxus providers within a React application tree.\r\n * It ensures that a stable scope is available and handles the automatic disposal\r\n * of the scope and its associated provider states when the component unmounts.\r\n *\r\n * Scopes can be nested by nesting `ProviderScope` components.\r\n *\r\n * @param {ProviderScopeProps} props - The component props.\r\n * @returns {React.ReactElement} The provider component wrapping the children.\r\n *\r\n * @example\r\n * ```tsx\r\n * ReactDOM.createRoot(document.getElementById('root')!).render(\r\n *   <React.StrictMode>\r\n *     <ProviderScope>\r\n *       <App />\r\n *     </ProviderScope>\r\n *   </React.StrictMode>,\r\n * )\r\n * ```\r\n */\r\nexport function ProviderScope({ children }: ProviderScopeProps): React.ReactElement {\r\n  const parentScope = React.useContext(ScopeContext);\r\n  const scopeRef = React.useRef<Scope | null>(null);\r\n\r\n  // Initialize the scope ref *during render* if it's null.\r\n  // useRef ensures this happens only once for the component instance's lifetime,\r\n  // persisting across StrictMode unmount/remount cycles.\r\n  if (scopeRef.current === null) {\r\n    scopeRef.current = createScope(parentScope);\r\n  }\r\n\r\n  // The scope instance is now guaranteed to exist.\r\n  const scope = scopeRef.current;\r\n\r\n  // Use useEffect for the disposal cleanup on final unmount.\r\n  React.useEffect(() => {\r\n    // Capture the ref value at the time the effect runs.\r\n    const scopeToDispose = scopeRef.current;\r\n    return () => {\r\n      // Only dispose if the scope exists and hasn't already been disposed.\r\n      if (scopeToDispose && !scopeToDispose.isDisposed) {\r\n        scopeToDispose.dispose();\r\n      }\r\n    };\r\n  }, []); // Empty dependency array ensures cleanup runs only on final unmount.\r\n\r\n  return (\r\n    <ScopeContext.Provider value={scope}>\r\n      {children}\r\n    </ScopeContext.Provider>\r\n  );\r\n}","import * as React from 'react';\r\nimport { Scope } from '../src/scope.js'; // Adjust path as needed\r\n\r\n/**\r\n * React Context to provide the Fluxus Scope to descendant components.\r\n */\r\nexport const ScopeContext = React.createContext<Scope | null>(null);\r\n\r\n/**\r\n * Hook to access the current Fluxus Scope from the context.\r\n * Throws an error if used outside of a ProviderScope.\r\n * @returns The current Fluxus Scope instance.\r\n */\r\nexport function useScope(): Scope {\r\n  const scope = React.useContext(ScopeContext);\r\n  if (!scope) {\r\n    throw new Error('useScope must be used within a ProviderScope');\r\n  }\r\n  return scope;\r\n}","import * as React from 'react';\r\nimport { useScope } from './context.js';\r\nimport { Provider } from '../src/types.js';\r\nimport { StateProviderInstance, StateUpdater, isStateProviderInstance } from '../src/providers/stateProvider.js';\r\n\r\n/**\r\n * A React hook that reads a provider's value from the current {@link Scope}\r\n * and subscribes to updates.\r\n *\r\n * The component calling this hook will re-render whenever the provider's\r\n * state changes in the scope. It uses `useSyncExternalStore` internally\r\n * to ensure compatibility with concurrent rendering features in React.\r\n *\r\n * Must be used within a {@link ProviderScope}.\r\n *\r\n * @template T The type of the value provided by the provider.\r\n * @param {Provider<T>} provider The provider whose value is to be read and watched.\r\n * @returns {T} The current value of the provider.\r\n * @throws {Error} If used outside of a `ProviderScope`.\r\n * @throws {Error} If the provider state has been disposed.\r\n * @throws {Error} If a circular dependency is detected during initialization.\r\n */\r\nexport function useProvider<T>(provider: Provider<T>): T {\r\n  const scope = useScope();\r\n\r\n  // Store the last known value to handle potential reads after scope disposal\r\n  const lastValueRef = React.useRef<T | undefined>(undefined);\r\n\r\n  // Subscribe to provider updates\r\n  const subscribe = React.useCallback((onStoreChange: () => void) => { // Renamed callback for clarity\r\n    try {\r\n        // scope.watch returns the unsubscribe function\r\n        return scope.watch(provider, () => {\r\n            onStoreChange(); // Call the callback provided by useSyncExternalStore\r\n        });\r\n    } catch (error: any) {\r\n        // If scope is disposed during subscribe, return a no-op unsubscribe\r\n        // Check for disposal errors more broadly\r\n        if (error instanceof Error && error.message.includes('disposed')) {\r\n            return () => {};\r\n        }\r\n        throw error; // Re-throw other errors\r\n    }\r\n  }, [scope, provider]); // Add scope and provider back as dependencies\r\n\r\n  // Get the current value (snapshot) of the provider\r\n  const getSnapshot = React.useCallback(() => {\r\n    try {\r\n      const currentValue = scope.read(provider);\r\n      lastValueRef.current = currentValue; // Cache the latest value\r\n      return currentValue;\r\n    } catch (error: any) {\r\n      // If scope is disposed, return the last known value if available\r\n      if (error.message === 'Scope has been disposed') {\r\n        if (lastValueRef.current !== undefined) {\r\n          // console.warn('useProvider: Scope disposed, returning last known value.');\r\n          return lastValueRef.current;\r\n        } else {\r\n          // This case should be rare (disposed before first successful read)\r\n          // Re-throwing might be better, but could crash the app.\r\n          // Depending on requirements, returning undefined or a specific error value might be options.\r\n          // For now, re-throw to make the issue visible during testing.\r\n          throw error;\r\n        }\r\n      }\r\n      // Re-throw other errors\r\n      throw error;\r\n    }\r\n  }, [scope, provider]); // Add scope and provider back as dependencies\r\n\r\n  // Initialize ref with the first snapshot if it's undefined\r\n  if (lastValueRef.current === undefined) {\r\n      try {\r\n        lastValueRef.current = scope.read(provider);\r\n      } catch {\r\n        // Ignore errors here, getSnapshot will handle them\r\n      }\r\n  }\r\n\r\n  // Optional: Define getServerSnapshot for SSR/server components.\r\n  // It should return the initial state on the server.\r\n  // const getServerSnapshot = React.useCallback(() => {\r\n  //   return scope.read(provider);\r\n  // }, [scope, provider]);\r\n\r\n  // Use useSyncExternalStore to manage the subscription and state updates.\r\n  return React.useSyncExternalStore(\r\n    subscribe,\r\n    getSnapshot\r\n    // getServerSnapshot // Uncomment if supporting SSR\r\n  );\r\n}\r\n\r\n/**\r\n * A React hook that returns the updater function for a {@link StateProviderInstance}.\r\n *\r\n * This hook allows components to update the state of a `StateProvider` without\r\n * needing to subscribe to its value (and thus avoiding re-renders when the\r\n * value changes if the component doesn't display it).\r\n *\r\n * The returned function has a stable identity across re-renders as long as the\r\n * provider and scope remain the same, making it safe to use in dependency arrays\r\n * of other hooks like `useEffect` or `useCallback`.\r\n *\r\n * Must be used within a {@link ProviderScope}.\r\n *\r\n * @template T The type of the state managed by the StateProvider.\r\n * @param {StateProviderInstance<T>} provider The StateProvider instance whose updater is needed.\r\n * @returns {(newValueOrFn: T | ((prev: T) => T)) => void} A stable function to update the provider's state.\r\n * @throws {Error} If used outside of a `ProviderScope`.\r\n * @throws {Error} If the provider is not a valid, initialized StateProvider in the scope.\r\n */\r\n// Return type is now the simplified version for the user: (newValueOrFn) => void\r\nexport function useProviderUpdater<T>(provider: StateProviderInstance<T>): (newValueOrFn: T | ((prev: T) => T)) => void {\r\n    const scope = useScope();\r\n\r\n    // Get the internal updater function from the scope.\r\n    // Fetch it directly to avoid stale closures related to the scope instance.\r\n    const internalUpdater = scope.updater(provider);\r\n\r\n    // Return a stable function that calls the internal updater with scope and provider.\r\n    // Use useCallback to ensure the returned function identity is stable if scope/provider don't change.\r\n    const stableUpdater = React.useCallback((newValueOrFn: T | ((prev: T) => T)) => {\r\n        // Call the internal updater, passing the current scope and provider instance.\r\n        internalUpdater(scope, provider, newValueOrFn);\r\n    }, [scope, provider, internalUpdater]); // internalUpdater dependency ensures if scope.updater changes behavior, we update\r\n\r\n    return stableUpdater;\r\n}\r\n\r\n// Example of a combined hook (less common, usually separate value/updater)\r\n// export function useAtom<T>(provider: StateProviderInstance<T>): [T, StateUpdater<T>] {\r\n//   const value = useProvider(provider);\r\n//   const updater = useProviderUpdater(provider);\r\n//   return [value, updater];\r\n// }"],"mappings":";;;;;AAAA,YAAYA,YAAW;;;ACAvB,YAAY,WAAW;AAMhB,IAAM,eAAqB,oBAA4B,IAAI;AAO3D,SAAS,WAAkB;AAChC,QAAM,QAAc,iBAAW,YAAY;AAC3C,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAChE;AACA,SAAO;AACT;;;AD8CI;AA3BG,SAAS,cAAc,EAAE,SAAS,GAA2C;AAClF,QAAM,cAAoB,kBAAW,YAAY;AACjD,QAAM,WAAiB,cAAqB,IAAI;AAKhD,MAAI,SAAS,YAAY,MAAM;AAC7B,aAAS,UAAU,YAAY,WAAW;AAAA,EAC5C;AAGA,QAAM,QAAQ,SAAS;AAGvB,EAAM,iBAAU,MAAM;AAEpB,UAAM,iBAAiB,SAAS;AAChC,WAAO,MAAM;AAEX,UAAI,kBAAkB,CAAC,eAAe,YAAY;AAChD,uBAAe,QAAQ;AAAA,MACzB;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,SACE,oBAAC,aAAa,UAAb,EAAsB,OAAO,OAC3B,UACH;AAEJ;;;AErEA,YAAYC,YAAW;AAsBhB,SAAS,YAAe,UAA0B;AACvD,QAAM,QAAQ,SAAS;AAGvB,QAAM,eAAqB,cAAsB,MAAS;AAG1D,QAAM,YAAkB,mBAAY,CAAC,kBAA8B;AACjE,QAAI;AAEA,aAAO,MAAM,MAAM,UAAU,MAAM;AAC/B,sBAAc;AAAA,MAClB,CAAC;AAAA,IACL,SAAS,OAAY;AAGjB,UAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,UAAU,GAAG;AAC9D,eAAO,MAAM;AAAA,QAAC;AAAA,MAClB;AACA,YAAM;AAAA,IACV;AAAA,EACF,GAAG,CAAC,OAAO,QAAQ,CAAC;AAGpB,QAAM,cAAoB,mBAAY,MAAM;AAC1C,QAAI;AACF,YAAM,eAAe,MAAM,KAAK,QAAQ;AACxC,mBAAa,UAAU;AACvB,aAAO;AAAA,IACT,SAAS,OAAY;AAEnB,UAAI,MAAM,YAAY,2BAA2B;AAC/C,YAAI,aAAa,YAAY,QAAW;AAEtC,iBAAO,aAAa;AAAA,QACtB,OAAO;AAKL,gBAAM;AAAA,QACR;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF,GAAG,CAAC,OAAO,QAAQ,CAAC;AAGpB,MAAI,aAAa,YAAY,QAAW;AACpC,QAAI;AACF,mBAAa,UAAU,MAAM,KAAK,QAAQ;AAAA,IAC5C,QAAQ;AAAA,IAER;AAAA,EACJ;AASA,SAAa;AAAA,IACX;AAAA,IACA;AAAA;AAAA,EAEF;AACF;AAsBO,SAAS,mBAAsB,UAAkF;AACpH,QAAM,QAAQ,SAAS;AAIvB,QAAM,kBAAkB,MAAM,QAAQ,QAAQ;AAI9C,QAAM,gBAAsB,mBAAY,CAAC,iBAAuC;AAE5E,oBAAgB,OAAO,UAAU,YAAY;AAAA,EACjD,GAAG,CAAC,OAAO,UAAU,eAAe,CAAC;AAErC,SAAO;AACX;","names":["React","React"]}
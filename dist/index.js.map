{"version":3,"sources":["../src/types.ts"],"sourcesContent":["/**\r\n * Represents a function that can be called to clean up resources or subscriptions.\r\n * @returns {void}\r\n */\r\nexport type Dispose = () => void;\r\n\r\n/**\r\n * Represents an object that holds a disposable resource or manages a lifecycle\r\n * that requires explicit cleanup.\r\n */\r\nexport interface Disposable {\r\n  /**\r\n   * Disposes of the resource or ends the lifecycle managed by this object.\r\n   * Calling dispose multiple times should be safe (idempotent).\r\n   */\r\n  dispose: Dispose;\r\n}\r\n\r\n/**\r\n * Provides read access to other providers within the current scope and methods\r\n * for managing the lifecycle of the current provider's state.\r\n * Passed to the provider's creation function.\r\n */\r\nexport interface ScopeReader {\r\n  /**\r\n   * Reads the current value of a provider without subscribing to updates.\r\n   * If the provider is not yet initialized in the scope, it will be created.\r\n   * @param provider The provider to read.\r\n   * @template P The type of the value provided by the dependency provider.\r\n   * @param provider The dependency provider to read.\r\n   * @returns The current value of the dependency provider within the current scope.\r\n   */\r\n  read<T>(provider: Provider<T>): T;\r\n\r\n  /**\r\n   * Watches the value of a provider and subscribes to updates.\r\n   * This is typically used by reactive providers or UI bindings.\r\n   * @template P The type of the value provided by the dependency provider.\r\n   * @param provider The dependency provider to watch.\r\n   * @returns The current value of the provider.\r\n   */\r\n  watch<T>(provider: Provider<T>): T; // Implementation detail: watching implies reading\r\n\r\n  /**\r\n   * Adds a cleanup function to be called when the provider's state\r\n   * associated with the current scope is disposed.\r\n   * @param callback The cleanup function to be executed.\r\n   */\r\n  onDispose(callback: Dispose): void;\r\n}\r\n\r\n/**\r\n * The core building block of Fluxus. A Provider defines how to create a value\r\n * within a specific scope. Providers are functions or objects that encapsulate\r\n * state creation logic.\r\n *\r\n * Providers are typically created using factory functions like `stateProvider`,\r\n * `computedProvider`, etc.\r\n *\r\n * They are identified by object identity, meaning you don't register them\r\n * with strings; you use the provider function/object itself as the key.\r\n *\r\n * @template T The type of the value created by the provider.\r\n * @param reader A {@link ScopeReader} instance to interact with the scope.\r\n * @returns The created value of type T.\r\n */\r\nexport type Provider<T> = (reader: ScopeReader) => T;\r\n\r\n/** A unique symbol to identify providers internally. */\r\nexport const $provider = Symbol.for('fluxus.provider');\r\n\r\n/**\r\n * A basic type guard to check if an unknown value is potentially a Fluxus provider.\r\n * Note: This is a very basic check and might need refinement if provider\r\n * structures become more complex (e.g., objects with specific methods).\r\n * @template T The potential type provided by the provider.\r\n * @param obj The value to check.\r\n * @returns True if the value is a function (the basic form of a provider), false otherwise.\r\n */\r\nexport function isProvider<T>(obj: unknown): obj is Provider<T> {\r\n    return typeof obj === 'function';\r\n}\r\n\r\n// More specific provider types (like StateProvider, ComputedProvider) will extend or utilize this base concept."],"mappings":";;;;;;;;;;AAqEO,IAAM,YAAY,OAAO,IAAI,iBAAiB;AAU9C,SAAS,WAAc,KAAkC;AAC5D,SAAO,OAAO,QAAQ;AAC1B;","names":[]}